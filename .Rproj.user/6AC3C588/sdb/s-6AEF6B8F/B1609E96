{
    "collab_server" : "",
    "contents" : "# load required packages\nlibrary(foreach)\nlibrary(doParallel)\n\n\n\n#####################\n#### Parameters ################################################################\n#####################\n\nPaths = 5 # number of Paths to simulate\nT = 3000 # number of generations to simulate\nP = 1000 # number of patches\nMutStep = 0.001 # mutation step\nM = 2 # number of mates\nK = 100 # number of offspring\nc = 1.5 # parameter\nk = 1 # parameter\n\n\nset.seed(632)\n\n#############################\n#### The model ####################################################################\n#############################\n\ncoopbreed_fun <- function(Paths, T, P, MutStep, M, K, c, k){\n  # breeder survival\n  Sb <- function(d){\n    1 - exp(-k * (1 - d))\n  }\n  Data = matrix(nrow = Paths, ncol = T)\n  \n  for(path in 1:Paths){ # for all paths\n    #print(paste(\"Path: \", path))\n    # Initialize Population\n    Popn = matrix(runif(P*2), nrow = 2, ncol = P)\n    #Popn[,1:10]\n    # one individual per patch \n    # two chromosomes per individual\n    \n    for(t in 1:T){ # for all generations\n      #print(paste(\"Generation: \", t))\n      mates = matrix(sample(1:P, M * P, replace = T), nrow = M, ncol = P)\n      #dim(mates)\n      #mates[,1:10]\n      # stores index of each mate of each individual\n      #Offspring <- list()\n      #Offspring[[1]] <- Popn[sample(2, K, replace = T), mates[sample(M,K,replace = T), 1:P]]\n      #Offspring[[2]] <- Popn[sample(2, K, replace = T),1:P]\n      \n      \n      Offspring = array(dim = c(K,2, P)) \n      #mates[Fathers,][1:10,1:10]\n      #mates[,1:10]\n      fun1 <- function(x) return(x[sample(M,1,replace = T)])\n      # Genotype 1: Choose one chromosome from Father. apply: choose \"Who is the father from the mates in each patch?\"\n      Offspring[,1,] <- Popn[sample(2, K, replace = T), apply(mates, 2, FUN = fun1)]\n      # choose chromose from mother:\n      Offspring[,2,] <- Popn[sample(2, K, replace = T),]\n      \n      # stores the genotypes of each off Offspring\n      \n      \n      OffspringPhenotype <- array(apply(Offspring,c(1,3), mean), c(K, P)) # mean jedes einzelnen nachkommkens (in each patch)\n      #length(apply(Offspring,c(1,3), mean))\n      #mean(c(Offspring[1,1,1], Offspring[1,2,1]))\n      #apply(Offspring,c(1,3), mean)[1]\n      \n      #dim(OffspringPhenotype)\n      AvgPhenotype = apply(OffspringPhenotype, 2, mean)  # average phenotype per patch\n      #length(AvgPhenotype)\n      GlobalAvgPhenotype = mean(t(AvgPhenotype))\n      \n      ProbLocal=(1 - AvgPhenotype)/(c * GlobalAvgPhenotype + (1 - AvgPhenotype))\n      BreederSurvival <- Sb(AvgPhenotype)\n      PopnNext = matrix(nrow = 2, ncol = P)\n      \n      \n      # TODO\n      \n      # start timing\n      #ptm <- proc.time() \n      # use all cores available, except 1\n      #cores <- parallel::detectCores() - 1\n      # set up cluster\n      #cl <- parallel::makeCluster(cores)\n      #doParallel::registerDoParallel(cl)\n      \n      for(i in 1:P){\n        #foreach::foreach(i = 1:P, .combine = c)%dopar%{ # for all patches\n        X = runif(1)\n        if(X > BreederSurvival[i]){\n          # Breeder Dies \n          Y=runif(1)\n          #########################################\n          #TODO\n          #ifelse(Y < ProbLocal[i], )\n          \n          if(Y < ProbLocal[i]){\n            #Winner Comes from Local Patch\n            PatchWinner = i\n            # Local Offspring Compete\n            Winner=sample(1:K,1,replace = T, prob = 1-t(OffspringPhenotype[,i]))\n            ################################\n          }else{\n            # Patches Compete\n            PatchWinner=sample(1:P, 1, replace = T, prob = AvgPhenotype)\n            # Offspring On Winning Patch Compete\n            Winner=sample(1:K,1,replace = T, prob = t(OffspringPhenotype[,PatchWinner]))\n          }\n          WinnersGenes= array(Offspring[Winner,,PatchWinner], c(1, 2))\n          \n          # Mutate Winner's Genes\n          WinnersGenes = WinnersGenes + MutStep * rnorm(2) \n          WinnersGenes[which(WinnersGenes <= 0)] = MutStep\n          WinnersGenes[which(WinnersGenes >= 1)] = 1 - MutStep\n          # Update Next Gen Population Array\n          PopnNext[,i] = t(WinnersGenes)\n        }else{\n          # Breeder Survives\n          PopnNext[,i] = Popn[,i]\n        }\n      }\n      \n      Popn = PopnNext\n      # Record Data\n      Data[path,t] = mean(apply(Popn, 1, mean))\n    }\n  }  \n  MeanPath = apply(Data, 2, mean)\n  SE=sqrt(apply(Data, 2, var)/Paths)\n  \n  return(list(\"Data\" = Data, \"Mean\" = MeanPath, \"SE\" = SE))\n}\n\n\n\n\nsystem.time({\n  res <- coopbreed_fun(Paths = 1, T = 0.1 *T, P = 0.1 *P, MutStep = MutStep, M = M, K = K, c= c, k= k)\n})\ncoopbreed_fun2 <- function(x) return(coopbreed_fun(Paths = 1, T = T, P = P, MutStep = MutStep, M = M, K = K, c= c, k= k))\nData2 = matrix(nrow = Paths, ncol = T)\n\napply(Data2, 1, coopbreed_fun2)\n\n#############################\n#### Plot results ################################################################\n#############################\nplot(1:(0.1*T), 1-res$Data[1,], type = \"l\", ylim = c(0, 1), col = \"grey\")\nfor(i in 1:nrow(res$Data)) lines(1:(0.1*T), 1-res$Data[i,], col = \"grey\")\n\nlines(1:(0.1*T), 1-res$Mean, col = \"red\")\n\ndim(Data)\n\n\n\n",
    "created" : 1492592068091.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1236692920",
    "id" : "B1609E96",
    "lastKnownWriteTime" : 1491984463,
    "last_content_update" : 1492592104549,
    "path" : "~/Dokumente/ST_cooperative_breeding/R_stuff/coopbreed/coopbreed_R.R",
    "project_path" : "coopbreed_R.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}