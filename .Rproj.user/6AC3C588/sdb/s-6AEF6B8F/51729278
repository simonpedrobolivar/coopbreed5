{
    "collab_server" : "",
    "contents" : "library(foreach)\nlibrary(doParallel)\n\ncoopbreedR <- function(Paths, T, P, MutStep, M, K, c, k){\n  # breeder survival\n  Sb <- function(d){\n    1 - exp(-k * (1 - d))\n  }\n\n  Data_vec = numeric(length = T)\n  # use all cores available, except 1\n  cores <- parallel::detectCores() - 1\n\n  # set up cluster\n  cl <- parallel::makeCluster(cores)\n  doParallel::registerDoParallel(cl)\n\n  Data <- foreach::foreach(path = 1:Paths, .combine = cbind) %dopar%{\n  # for all paths\n\n    #print(paste(\"Path: \", path))\n    # Initialize Population\n    Popn = matrix(runif(P*2), nrow = 2, ncol = P)\n    #Popn[,1:10]\n    # one individual per patch\n    # two chromosomes per individual\n\n    for(t in 1:T){ # for all generations\n      #print(paste(\"Generation: \", t))\n      mates = matrix(sample(1:P, M * P, replace = T), nrow = M, ncol = P)\n      #dim(mates)\n      #mates[,1:10]\n      # stores index of each mate of each individual\n      #Offspring <- list()\n      #Offspring[[1]] <- Popn[sample(2, K, replace = T), mates[sample(M,K,replace = T), 1:P]]\n      #Offspring[[2]] <- Popn[sample(2, K, replace = T),1:P]\n\n\n      Offspring = array(dim = c(K,2, P))\n      #mates[Fathers,][1:10,1:10]\n      #mates[,1:10]\n      fun1 <- function(x) return(x[sample(M,1,replace = T)])\n      # Genotype 1: Choose one chromosome from Father. apply: choose \"Who is the father from the mates in each patch?\"\n      Offspring[,1,] <- Popn[sample(2, K, replace = T), apply(mates, 2, FUN = fun1)]\n      # choose chromose from mother:\n      Offspring[,2,] <- Popn[sample(2, K, replace = T),]\n\n      # stores the genotypes of each off Offspring\n\n\n      OffspringPhenotype <- array(apply(Offspring,c(1,3), mean), c(K, P)) # mean jedes einzelnen nachkommkens (in each patch)\n      #length(apply(Offspring,c(1,3), mean))\n      #mean(c(Offspring[1,1,1], Offspring[1,2,1]))\n      #apply(Offspring,c(1,3), mean)[1]\n\n      #dim(OffspringPhenotype)\n      AvgPhenotype = apply(OffspringPhenotype, 2, mean)  # average phenotype per patch\n      #length(AvgPhenotype)\n      GlobalAvgPhenotype = mean(t(AvgPhenotype))\n\n      ProbLocal=(1 - AvgPhenotype)/(c * GlobalAvgPhenotype + (1 - AvgPhenotype))\n      BreederSurvival <- Sb(AvgPhenotype)\n      PopnNext = matrix(nrow = 2, ncol = P)\n\n\n      # TODO\n\n      # start timing\n      #ptm <- proc.time()\n      # use all cores available, except 1\n      #cores <- parallel::detectCores() - 1\n      # set up cluster\n      #cl <- parallel::makeCluster(cores)\n      #doParallel::registerDoParallel(cl)\n\n\n\n      for(i in 1:P){\n        #foreach::foreach(i = 1:P, .combine = c)%dopar%{ # for all patches\n        X = runif(1)\n        if(X > BreederSurvival[i]){\n          # Breeder Dies\n          Y=runif(1)\n          #########################################\n          #TODO\n          #ifelse(Y < ProbLocal[i], )\n\n          if(Y < ProbLocal[i]){\n            #Winner Comes from Local Patch\n            PatchWinner = i\n            # Local Offspring Compete\n            Winner=sample(1:K,1,replace = T, prob = 1-t(OffspringPhenotype[,i]))\n            ################################\n          }else{\n            # Patches Compete\n            PatchWinner=sample(1:P, 1, replace = T, prob = AvgPhenotype)\n            # Offspring On Winning Patch Compete\n            Winner=sample(1:K,1,replace = T, prob = t(OffspringPhenotype[,PatchWinner]))\n          }\n          WinnersGenes= array(Offspring[Winner,,PatchWinner], c(1, 2))\n\n          # Mutate Winner's Genes\n          WinnersGenes = WinnersGenes + MutStep * rnorm(2)\n          WinnersGenes[which(WinnersGenes <= 0)] = MutStep\n          WinnersGenes[which(WinnersGenes >= 1)] = 1 - MutStep\n          # Update Next Gen Population Array\n          PopnNext[,i] = t(WinnersGenes)\n        }else{\n          # Breeder Survives\n          PopnNext[,i] = Popn[,i]\n        }\n      }\n\n      Popn = PopnNext\n      # Record Data\n      Data_vec[t] = mean(apply(Popn, 1, mean))\n    }\n    Data_vec\n  }\n  #MeanPath = apply(Data, 2, mean)\n  #SE=sqrt(apply(Data, 2, var)/Paths)\n  return(Data)\n  #return(list(\"Data\" = Data, \"Mean\" = MeanPath, \"SE\" = SE))\n}\n\n",
    "created" : 1492592112142.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3789925065",
    "id" : "51729278",
    "lastKnownWriteTime" : 1492593365,
    "last_content_update" : 1492593365751,
    "path" : "~/Dokumente/ST_cooperative_breeding/R_stuff/coopbreed/R/coopbreedR.R",
    "project_path" : "R/coopbreedR.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}